#!/usr/bin/env python3

# Signature verification tool for Signing Meter.
#
# For the following example the signature will be verified successfully:
#
#     $ sign-verify --pubkey=046858b701931d153524d03b28f8b2758d33dd6f76282184ad825e31283e076e1f8c1747f16f9df5b5123594fe867b282a2fb5ab704d5230445cc820e3880b4db7 --signature=304402205d3c7fbdc68c0484475b15051f51192230f37c3590de7060f31f7c07137089fa022035fae5dd765f558680762acc65e35e71e5862370ad1da8cbe87a8e22cb6418eb --digest=6bdab37edc9f9b29c125056eed1d7506b5f346743306eac2e3ae6789adda746d
#


from argparse import ArgumentParser
from argparse import FileType
from ecdsa import BadSignatureError
from ecdsa import VerifyingKey
from ecdsa import ellipticcurve
from ecdsa import util
from ecdsa.curves import Curve
from hashlib import sha256
import string
import sys


SEC1_UNCOMPRESSED_POINT_MARKER = 0x04

# Curve parameters of secp256r1 from 'SEC 2:  Recommended Elliptic Curve Domain
# Parameters' (https://www.secg.org/sec2-v2.pdf), section 2.4.2 'Recommended
# Parameters secp256r1'.
P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
A = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
GX = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
GY = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
R = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

CURVE_SECP256R1 = ellipticcurve.CurveFp(P, A, B)
GENERATOR_SECP256R1 = ellipticcurve.Point(CURVE_SECP256R1, GX, GY, R)

# Curve secp256r1. The Python ecdsa package does not ship it for whatever
# reason. OID from http://oid-info.com/get/1.2.840.10045.3.1.7.
SECP256r1 = Curve("SECP256r1", CURVE_SECP256R1, GENERATOR_SECP256R1, (1, 2, 840, 10045, 3, 1, 7), "secp256r1")




def hex_data_or_file(arg):
    hex_digits = set(string.hexdigits)
    if all(c in hex_digits for c in arg):
        return bytes.fromhex(arg)
    else:
        return open(arg, 'rb').read()


def public_key_from_sec1_point_data(data):
    assert len(data) == 65
    assert data[0] == SEC1_UNCOMPRESSED_POINT_MARKER

    x = int.from_bytes(data[1:33], 'big')
    y = int.from_bytes(data[33:65], 'big')
    point = ellipticcurve.Point(CURVE_SECP256R1, x, y)
    return VerifyingKey.from_public_point(point, curve=SECP256r1, hashfunc=sha256)




parser = ArgumentParser(
    description='ECDSDA signature verification tool for Signing Meter',
    epilog='HEX_OR_FILE arguments may be either immediate data as hex string or the name of a file to read the data from.')
parser.add_argument('--verbose', action='store_true',
    help='Always output result')
parser.add_argument('--pubkey', metavar='HEX_OR_FILE', required=True,
    type=hex_data_or_file,
    help='public key uncompressed point in SEC1 format')
parser.add_argument('--signature', metavar='FILE', required=True,
    type=hex_data_or_file,
    help='ASN.1 encoded signature')
# TODO: Add support for verifying data.
parser.add_argument('--digest', metavar='HEX_DATA', required=True,
    type=hex_data_or_file,
    help='SHA-256 digest to verify signature for')

args = parser.parse_args()


digest = args.digest
pubkey = public_key_from_sec1_point_data(args.pubkey)
signature = args.signature


try:
    result = pubkey.verify_digest(signature, digest, sigdecode=util.sigdecode_der)
    if args.verbose:
        print('success')
    sys.exit(0)
except BadSignatureError:
    print('failure', file=sys.stderr)
    sys.exit(1)
