#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import namedtuple
from enum import IntEnum
from pprint import pprint
from pymodbus.client.sync import ModbusSerialClient
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadBuilder, BinaryPayloadDecoder
from six import iteritems
from struct import pack
from sunspec.constants import SunspecModel, SunspecOffsets, SunspecIdentifier, SunspecDefaultValue

import binascii
import os
import string


# --------------------------------------------------------------------------- #
# Logging
# --------------------------------------------------------------------------- #
import logging
_logger = logging.getLogger(__name__)
_logger.setLevel(logging.DEBUG)
logging.basicConfig()


Item = namedtuple('Item', 'name, value')


# --------------------------------------------------------------------------- # 
# Signing Meter Common Constants
# --------------------------------------------------------------------------- # 
class SigningMeterOffsets(object):
    SunSpecId                                = 40000
    CommonBlock                              = 40002
    MeterBlock                               = 40070
    BsmMeterBlock                            = 40177
    SignedCurrentStateBlock                  = 40471
    SignedTurnOnStateBlock                   = 40719
    SignedTurnOffStateBlock                  = 40967


class BsmMeterBlockOffsets(IntEnum):
    EPOCH_TIME_UTC_SECONDS                   = 63
    LOCAL_TIME_ZONE_OFFSET_MINUTES           = 65
    DIGITAL_OUTPUT_STATE                     = 67
    METADATA_1                               = 78
    METADATA_1_LENGTH                        = 70
    METADATA_2                               = 148
    METADATA_2_LENGTH                        = 50
    METADATA_3                               = 198
    METADATA_3_LENGTH                        = 50


class SignedStateBlockOffsets(object):
    Status                                   = 3


class SignedStateBlockStatus(IntEnum):
    VALID = 0
    INVALID = 1
    UPDATING = 2
    FAILED = 3


# --------------------------------------------------------------------------- # 
# Common Functions
# --------------------------------------------------------------------------- # 
def create_sunspec_sync_client(args):
    """ A quick helper method to create a sunspec
    client.

    :param args: command line arguments parsed by ArgumentParser
    :returns: an initialized SunspecClient
    """
    modbus = ModbusSerialClient(method='rtu', port=args.device, timeout=args.timeout, baudrate=args.baud, parity='E')
    modbus.connect()
    client = SunspecClient(modbus, unit=args.unit, chunk_size=args.chunk_size)
    client.initialize()
    return client


def auto_int(x):
    result = None

    if isinstance(x, int):
        # Pass-through integer values.
        result = x
    elif x != None:
        # Parse everything else but 'None' with auto base detection.
        result = int(x, 0)

    return result


def parse_args():
    # Attempt to retrieve communication paramter defaults from environment
    # variables. This will allow short command lines for repeated invocations.
    device = os.getenv('MBTOOL_DEVICE')
    baud = auto_int(os.getenv('MBTOOL_BAUD', 115200))
    unit = auto_int(os.getenv('MBTOOL_UNIT'))
    timeout = auto_int(os.getenv('MBTOOL_TIMEOUT', 10))
    chunk = auto_int(os.getenv('MBTOOL_CHUNK', 125))

    parser = ArgumentParser(description='Signing Meter Modbus Tool',
        epilog='You may specify communication parameters also by environment variables. Use MBTOOL_DEVICE, MBTOOL_BAUD, MBTOOL_UNIT, MBTOOL_TIMEOUT, and MBTOOL_CHUNK.')
    # Default parser for communication parameters.
    parser.add_argument('--device', metavar='DEVICE', help='serial device', required=(device is None), default=device)
    parser.add_argument('--baud', metavar='BAUD', type=int, help='serial baud rate', default=baud)
    parser.add_argument('--timeout', metavar='SECONDS', type=float, help='request timeout', default=timeout)
    parser.add_argument('--unit', metavar='UNIT', type=int, help='Modbus RTU unit number', required=(unit is None), default=unit)
    parser.add_argument('--chunk-size', metavar='REGISTERS', type=int, help='Maximum amount of registers to read at once', default=chunk)

    subparsers = parser.add_subparsers(help='sub commands')

    # The original main function from initial Modbus Tool.
    test_parser = subparsers.add_parser('main', help='run original test code from main')
    test_parser.set_defaults(func=test_main)
    test_parser.add_argument('--raw-data', action='store_true', help='Fetch raw data for unknown blocks')

    # Read and interpret SunSpec block.
    read_block_parser = subparsers.add_parser('read-block', help='read sunspec block')
    read_block_parser.set_defaults(func=read_block)
    read_block_parser.add_argument('--offset', type=auto_int, help='Modbus block offset (words)')
    read_block_parser.add_argument('--length', type=auto_int, help='Block length (words)')

    # Hex-dump registers.
    dump_parser = subparsers.add_parser('dump', help='Dump registers')
    dump_parser.set_defaults(func=dump)
    dump_parser.add_argument('--offset', type=auto_int, help='Modbus block offset (words)')
    dump_parser.add_argument('--length', type=auto_int, help='Block length (words)')

    # Set meter time.
    set_parser = subparsers.add_parser('set', help='Set values')
    set_parser.set_defaults(func=set_values )
    set_parser.add_argument('--epoch-time', type=auto_int, help='Epoch time UTC [seconds]')
    set_parser.add_argument('--tz-offset', type=auto_int, help='Local timezone UTC offset [minutes]')
    set_parser.add_argument('--meta1', help='Metadata string 1')
    set_parser.add_argument('--meta2', help='Metadata string 2')
    set_parser.add_argument('--meta3', help='Metadata string 3')

    # Request generating a snapshot (for a given snapshot name).
    snapshot_parser = subparsers.add_parser('snapshot', help='Create snapshot')
    snapshot_parser.set_defaults(func=snapshot)
    snapshot_parser.add_argument('name', help='Snapshot name')

    return parser.parse_args()


# --------------------------------------------------------------------------- # 
# Sunspec Client
# --------------------------------------------------------------------------- # 
class SunspecDecoder(BinaryPayloadDecoder):
    """ A decoder that deals correctly with the sunspec
    binary format.
    """

    def __init__(self, payload, byteorder, wordorder):
        """ Initialize a new instance of the SunspecDecoder

        .. note:: This is always set to big endian byte order
        as specified in the protocol.
        """
        byteorder = Endian.Big
        BinaryPayloadDecoder.__init__(self, payload, byteorder, wordorder)

    def decode_binary_string(self, size=1):
        return super().decode_string(size)

    def decode_string(self, size=1):
        """ Decodes a string from the buffer

        :param size: The size of the string to decode
        """
        string = super().decode_string(size)
        return string.split(SunspecDefaultValue.String)[0]

class SunspecBuilder(BinaryPayloadBuilder):
    def __init__(self, payload=None, byteorder=Endian.Big, wordorder=Endian.Big, repack=False):
        BinaryPayloadBuilder.__init__(self, payload, byteorder, wordorder, repack)

    def add_string(self, value, size=1):
        assert(size % 2 == 0)
        assert(len(value) <= size)

        # TODO: How to deal with non-ASCII characters? The PyModbus stack
        # operates on characters so we have to make assumptions about the
        # encoding.

        padding = '\x00' * (size - len(value))
        super().add_string(value + padding)

class SunspecClient(object):

    def __init__(self, client, unit=None, chunk_size=125):
        """ Initialize a new instance of the client

        :param client: The modbus client to use
        """
        self.client = client
        self.unit = unit
        self.chunk_size = chunk_size
        self.offset = SunspecOffsets.CommonBlock

    def initialize(self):
        """ Initialize the underlying client values

        :returns: True if successful, false otherwise
        """
        decoder  = self.get_device_block(self.offset, 2)
        if decoder.decode_32bit_uint() == SunspecIdentifier.Sunspec:
            return True
        self.offset = SunspecOffsets.AlternateCommonBlock
        decoder  = self.get_device_block(self.offset, 2)
        return decoder.decode_32bit_uint() == SunspecIdentifier.Sunspec

    def get_common_block(self):
        """ Read and return the sunspec common information
        block.

        :returns: A dictionary of the common block information
        """
        length  = SunspecOffsets.CommonBlockLength
        decoder = self.get_device_block(self.offset, length)
        return {
            'SunSpec_ID':       decoder.decode_32bit_uint(),
            'SunSpec_DID':      decoder.decode_16bit_uint(),
            'SunSpec_Length':   decoder.decode_16bit_uint(),
            'Manufacturer':     decoder.decode_string(size=32),
            'Model':            decoder.decode_string(size=32),
            'Options':          decoder.decode_string(size=16),
            'Version':          decoder.decode_string(size=16),
            'SerialNumber':     decoder.decode_string(size=32),
            'DeviceAddress':    decoder.decode_16bit_uint(),
            'Pad':              decoder.decode_16bit_uint(),
        }

    def get_device_block(self, offset, size):
        """ A helper method to retrieve the next device block

        .. note:: We will read 2 more registers so that we have
        the information for the next block.

        :param offset: The offset to start reading at
        :param size: The size of the offset to read
        :returns: An initialized decoder for that result
        """
        _logger.debug("reading device block[{}..{}]".format(offset, offset + size))

        registers = []
        remaining = size

        if size > 0:
            while remaining > 0:
                current_chunk = min(remaining, self.chunk_size)
                response = self.client.read_holding_registers(offset, current_chunk, unit=self.unit)

                registers += response.registers
                offset += current_chunk
                remaining -= current_chunk

        return SunspecDecoder.fromRegisters(registers)

    def get_all_device_blocks(self, raw_data=False):
        """ Retrieve all the available blocks in the supplied
        sunspec device.

        .. note:: Since we do not know how to decode the available
        blocks, this returns a list of dictionaries of the form:

            decoder: the-binary-decoder,
            model:   the-model-identifier (name)

        :returns: A list of the available blocks
        """
        blocks = []
        offset = self.offset + 2
        model  = SunspecModel.CommonBlock
        while model != SunspecModel.EndOfSunSpecMap:
            decoder = self.get_device_block(offset, 2)
            model   = decoder.decode_16bit_uint()
            start   = offset
            length  = decoder.decode_16bit_uint()

            offset += 2

            if raw_data:
                decoder = self.get_device_block(offset, length)

            offset += length

            blocks.append({
                'model' : model,
                'name'  : SunspecModel.lookup(model),
                'start' : start,
                'length': length,
            })
        return blocks

    def read_holding_registers(self, offset, length):
        _logger.debug('reading registers {}..{}'.format(offset, offset + length))

        registers = []
        remaining = length

        while remaining > 0:
            current_chunk = min(remaining, self.chunk_size)
            response = self.client.read_holding_registers(offset, current_chunk, unit=self.unit)

            registers += response.registers
            offset += current_chunk
            remaining -= current_chunk

        return registers

    def write_registers(self, offset, values):
        _logger.debug('write registers {} with {}'.format(offset, values))
        self.client.write_registers(offset, values, unit=self.unit)


#------------------------------------------------------------
# A quick test runner
#------------------------------------------------------------
def test_main(args):
    client = create_sunspec_sync_client(args)

    # print out all the device common block
    common = client.get_common_block()
    for key, value in iteritems(common):
        if key == "SunSpec_DID":
            value = SunspecModel.lookup(value)
        print("{:<20}: {}".format(key, value))

    # print out all the available device blocks
    blocks = client.get_all_device_blocks(args.raw_data)
    for block in blocks:
        print(block)

    client.client.close()


def read_block(args):
    client = create_sunspec_sync_client(args)
    decoder = client.get_device_block(args.offset, args.length)

    # FIXME: Complete and clean-up block decoding. Decode more than just signed
    # state blocks.
    entries = [
        Item('Model ID', decoder.decode_16bit_uint()),
        Item('Length', decoder.decode_16bit_uint()),
        Item('Type', decoder.decode_16bit_uint()),
        Item('Status', decoder.decode_16bit_uint()),
        Item('Active Energy Exported Total', (decoder.decode_32bit_uint(), decoder.decode_16bit_int(), decoder.decode_16bit_uint())),
        Item('Active Power Total', (decoder.decode_32bit_int(), decoder.decode_16bit_int(), decoder.decode_16bit_uint())),
        Item('Server ID', decoder.decode_string(size=16)),
        Item('Response Counter', decoder.decode_32bit_uint()),
        Item('Operating Seconds', decoder.decode_32bit_uint()),
        Item('Epoch Time UTC', decoder.decode_32bit_uint()),
        Item('Local Time Zone Offset', decoder.decode_16bit_int()),
        Item('Digital Input State', decoder.decode_16bit_uint()),
        Item('Digital Output State', decoder.decode_16bit_uint()),
        Item('Last Modification DI Operating Seconds', decoder.decode_32bit_uint()),
        Item('Last Modification DI Epoch Time UTC', decoder.decode_32bit_uint()),
        Item('Last Modification DI Local Time Zone Offset', decoder.decode_16bit_int()),
        Item('Last Modification DO Operating Seconds', decoder.decode_32bit_uint()),
        Item('Last Modification DO Epoch Time UTC', decoder.decode_32bit_uint()),
        Item('Last Modification DO Local Time Zone Offset', decoder.decode_16bit_int()),
        Item('Metadata 1', decoder.decode_string(size=140)),
        Item('Metadata 2', decoder.decode_string(size=100)),
        Item('Metadata 3', decoder.decode_string(size=100)),
    ]

    signature_length = decoder.decode_16bit_uint()
    raw = decoder.decode_binary_string(size=74)
    signature = binascii.hexlify(raw[:signature_length])

    entries.append(Item('Signature', signature))

    pprint(entries)

    client.client.close()


def into_chunks(array, length):
    for i in range(0, len(array), length):
        yield array[i:i + length]


def register_hexdump(registers, offset=0):
    chunk_length = 8
    chunks = list(into_chunks(registers, chunk_length))

    start = offset

    for i in range(0, len(chunks)):
        chunk = chunks[i]

        # Hex data of registers.
        hex_chunk = ' '.join(map(lambda x: '{:04x}'.format(x), chunk))

        # Printable characters from big-endian register data.
        payload_chunk = b''.join(pack('>H', x) for x in chunk)
        printable = ''.join(map(lambda x: chr(x) if x >= 32 and x < 127 else '.', payload_chunk))

        print('{:8}: {:40} {}'.format(start, hex_chunk, printable))
        start += len(chunk)


def dump(args):
    client = create_sunspec_sync_client(args)

    registers = client.read_holding_registers(args.offset, args.length)
    register_hexdump(registers, args.offset)

    client.client.close()


def set_values(args):
    client = create_sunspec_sync_client(args)
    offset = None

    # TODO: Add support for setting the remaining values.

    if args.epoch_time != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.EPOCH_TIME_UTC_SECONDS
        builder = SunspecBuilder()
        builder.add_32bit_uint(args.epoch_time)
        client.write_registers(offset, builder.to_registers())

    if args.tz_offset != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.LOCAL_TIME_ZONE_OFFSET_MINUTES
        builder = SunspecBuilder()
        builder.add_16bit_int(args.tz_offset)
        client.write_registers(offset, builder.to_registers())

    if args.meta1 != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.METADATA_1
        builder = SunspecBuilder()
        builder.add_string(args.meta1, size=2 * BsmMeterBlockOffsets.METADATA_1_LENGTH)
        client.write_registers(offset, builder.to_registers())

    if args.meta2 != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.METADATA_2
        builder = SunspecBuilder()
        builder.add_string(args.meta2, size=2 * BsmMeterBlockOffsets.METADATA_2_LENGTH)
        client.write_registers(offset, builder.to_registers())

    if args.meta3 != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.METADATA_3
        builder = SunspecBuilder()
        builder.add_string(args.meta3, size=2 * BsmMeterBlockOffsets.METADATA_3_LENGTH)
        client.write_registers(offset, builder.to_registers())

    client.client.close()


def snapshot(args):
    client = create_sunspec_sync_client(args)

    trigger_offsets = \
        {
            'scs': SigningMeterOffsets.SignedCurrentStateBlock + SignedStateBlockOffsets.Status,
            'stons': SigningMeterOffsets.SignedTurnOnStateBlock + SignedStateBlockOffsets.Status,
            'stoffs': SigningMeterOffsets.SignedTurnOffStateBlock + SignedStateBlockOffsets.Status,
        }

    offset = trigger_offsets[args.name.lower()]

    if offset != None:
        client.write_registers(offset, SignedStateBlockStatus.UPDATING)

    client.client.close()


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
