#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import namedtuple
from crypto.curves import SECP256r1
from crypto.util import verify_signed_digest
from enum import IntEnum
from hashlib import sha256
from hexdump import hexdump
from pprint import pprint, pformat
from pymodbus.client.sync import ModbusSerialClient
from pymodbus.register_write_message import WriteMultipleRegistersResponse
from six import iteritems
from struct import pack
from sunspec.client import SunspecClient, SunspecBuilder
from sunspec.constants import SunspecModel, SunspecOffsets, SunspecIdentifier, SunspecDefaultValue

import binascii
import os
import string
import sys


MODEL_DATA_INDENT = '    '


SunspecModelData = namedtuple('SunspecModelData',
    [
        'model_id',
        'length',
        'payload',
    ])
ScaledValue = namedtuple('ScaledValue', 'value, scaler, unit')
SnapshotTimestamp = namedtuple('SnapshotTimestamp', 'operating_seconds, epoch_time_utc_seconds, local_timezone_offset_minutes')
SigningMeterData = namedtuple('SigningMeterData',
    [
        'modbus_address',
        'modbus_baud_rate',
        'error_code',
        'serial_number_meter',
        'serial_number_communication_module',
        'software_version_meter',
        'software_version_communication_module',
        'meter_address_1',
        'meter_address_2',
        'power_down_counter',
        'response_counter',
        'current_time',
        'di_state',
        'do_state',
        'last_di_modification',
        'last_do_modification',
        'metadata_1',
        'metadata_2',
        'metadata_3',
        'ecdsa_curve_name',
        'ecdsa_public_key',
    ])
SignedStateData = namedtuple('SignedStateData',
    [
        'type',
        'status',
        'active_energy_exported_total',
        'active_energy_exported_total_scale_factor',
        'active_power_total',
        'active_power_total_scale_factor',
        'server_id',
        'response_counter',
        'timestamp',
        'di_state',
        'do_state',
        'last_di_modification',
        'last_do_modification',
        'metadata_1',
        'metadata_2',
        'metadata_3',
        'signature',
    ])


BlockInfo = namedtuple('BlockInfo', 'name, short_name, model, offset, length, is_snapshot')



# --------------------------------------------------------------------------- # 
# Signing Meter Common Constants
# --------------------------------------------------------------------------- # 
class SigningMeterOffsets(IntEnum):
    SunSpecId                                = 40000
    CommonBlock                              = 40002
    ThreePhaseMeterBlock                     = 40070
    SigningMeterBlock                        = 40177
    SignedCurrentStateBlock                  = 40471
    SignedTurnOnStateBlock                   = 40717
    SignedTurnOffStateBlock                  = 40963
    EndOfSunSpecMapBlock                     = 41209


class SigningMeterModels(IntEnum):
    SigningMeter                             = SunspecModel.VendorPrivateStart + 0
    SignedState                              = SunspecModel.VendorPrivateStart + 1


class SigningMeterModelPayloadLengths(IntEnum):
    SigningMeter                             = 292
    SignedState                              = 244


class SigningMeterLengths(IntEnum):
    SigningMeterBlock                        = SigningMeterModelPayloadLengths.SigningMeter + SunspecOffsets.HeaderLength
    SignedCurrentStateBlock                  = SigningMeterModelPayloadLengths.SignedState + SunspecOffsets.HeaderLength
    SignedTurnOnStateBlock                   = SigningMeterModelPayloadLengths.SignedState + SunspecOffsets.HeaderLength
    SignedTurnOffStateBlock                  = SigningMeterModelPayloadLengths.SignedState + SunspecOffsets.HeaderLength


class SigningMeterBlockOffsets(IntEnum):
    ModbusDeviceAddress                      = 2
    ModbusDeviceAddressLength                = 1
    ModbusBaudRate                           = 3
    ModbusBaudRateLength                     = 2
    ErrorCodeLength                          = 4
    SerialNumberMeterLength                  = 8
    SerialNumberCommunicationModuleLength    = 8
    SoftwareVersionMeterLength               = 8
    SoftwareVersionCommunicationModuleLength = 8
    MeterAddress1Length                      = 8
    MeterAddress2Length                      = 8
    EpochTimeUtcSeconds                      = 63
    LocalTimezoneOffsetMinutes               = 65
    DigitalOutputState                       = 67
    Metadata1                                = 78
    Metadata1Length                          = 70
    Metadata2                                = 148
    Metadata2Length                          = 50
    Metadata3                                = 198
    Metadata3Length                          = 50
    EcdsaCurveNameLength                     = 8
    EcdsaPublicKeyLength                     = 37


class SignedStateBlockOffsets(object):
    Status                                   = 3
    ServerId                                 = 12
    ServerIdLength                           = 8
    Metadata1Length                          = SigningMeterBlockOffsets.Metadata1Length
    Metadata2Length                          = SigningMeterBlockOffsets.Metadata2Length
    Metadata3Length                          = SigningMeterBlockOffsets.Metadata3Length
    SignatureLength                          = 37


class SignedStateBlockStatus(IntEnum):
    VALID = 0
    INVALID = 1
    UPDATING = 2
    FAILED = 3


class DlmsUnits(IntEnum):
    MINUTES = 6
    SECONDS = 7
    WATTS = 27
    WATT_HOURS = 30
    UNITLESS = 255


# --------------------------------------------------------------------------- #
# Block Information
# --------------------------------------------------------------------------- #

# FIXME: Complete block infos.
BLOCK_INFOS = \
    [
        BlockInfo(
            'Signing Meter',
            'sm',
            SigningMeterModels.SigningMeter,
            SigningMeterOffsets.SigningMeterBlock,
            SigningMeterLengths.SigningMeterBlock,
            True),
        BlockInfo(
            'Signed Current State',
            'scs',
            SigningMeterModels.SignedState,
            SigningMeterOffsets.SignedCurrentStateBlock,
            SigningMeterLengths.SignedCurrentStateBlock,
            True),
        BlockInfo(
            'Signed Turn-On State',
            'stons',
            SigningMeterModels.SignedState,
            SigningMeterOffsets.SignedTurnOnStateBlock,
            SigningMeterLengths.SignedTurnOnStateBlock,
            True),
        BlockInfo(
            'Signed Turn-Off State',
            'stoffs',
            SigningMeterModels.SignedState,
            SigningMeterOffsets.SignedTurnOffStateBlock,
            SigningMeterLengths.SignedTurnOffStateBlock,
            True),
    ]


# --------------------------------------------------------------------------- # 
# Common Functions
# --------------------------------------------------------------------------- # 
def auto_int(x):
    result = None

    if isinstance(x, int):
        # Pass-through integer values.
        result = x
    elif x != None:
        # Parse everything else but 'None' with auto base detection.
        result = int(x, 0)

    return result


def block_info_for_short_name(short_name):
    filtered = filter(lambda x: x.short_name == short_name, BLOCK_INFOS)
    result = next(filtered, None)

    # We expect at most one match.
    assert next(filtered, None) == None

    return result


def check_write_result(result):
    if isinstance(result, WriteMultipleRegistersResponse):
        # Nothing to see here ...
        pass
    else:
        print('Writing registers failed ({}).'.format(result), file=sys.stderr)
        sys.exit(1);


def create_sunspec_sync_client(args):
    """ A quick helper method to create a sunspec
    client.

    :param args: command line arguments parsed by ArgumentParser
    :returns: an initialized SunspecClient
    """
    modbus = ModbusSerialClient(method='rtu', port=args.device, timeout=args.timeout, baudrate=args.baud, parity='E')
    modbus.connect()
    client = SunspecClient(modbus, unit=args.unit, chunk_size=args.chunk_size)
    client.initialize()
    return client


def decode_binary_string(decoder, size):
    length = decoder.decode_16bit_uint()
    string = decoder.decode_binary_string(size=size)

    assert length <= size
    return string[:length]


def decode_block_payload(decoder, model_id, length):
    result = None

    # FIXME: Add support for remaining blocks of signing meter.

    if model_id == SigningMeterModels.SigningMeter and length == SigningMeterModelPayloadLengths.SigningMeter:
        result = SigningMeterData(
            modbus_address=decoder.decode_16bit_uint(),
            modbus_baud_rate=decoder.decode_32bit_uint(),
            error_code=decoder.decode_string(size=2 * SigningMeterBlockOffsets.ErrorCodeLength),
            serial_number_meter=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SerialNumberMeterLength),
            serial_number_communication_module=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SerialNumberCommunicationModuleLength),
            software_version_meter=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SoftwareVersionMeterLength),
            software_version_communication_module=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SoftwareVersionCommunicationModuleLength),
            meter_address_1=decoder.decode_string(size=2 * SigningMeterBlockOffsets.MeterAddress1Length),
            meter_address_2=decoder.decode_string(size=2 * SigningMeterBlockOffsets.MeterAddress2Length),
            power_down_counter=decoder.decode_32bit_uint(),
            response_counter=decoder.decode_32bit_uint(),
            current_time=decode_timestamp(decoder),
            di_state=decoder.decode_16bit_uint(),
            do_state=decoder.decode_16bit_uint(),
            last_di_modification=decode_timestamp(decoder),
            last_do_modification=decode_timestamp(decoder),
            metadata_1=decoder.decode_string(size=2 * SigningMeterBlockOffsets.Metadata1Length),
            metadata_2=decoder.decode_string(size=2 * SigningMeterBlockOffsets.Metadata2Length),
            metadata_3=decoder.decode_string(size=2 * SigningMeterBlockOffsets.Metadata3Length),
            ecdsa_curve_name=decoder.decode_string(size=2 * SigningMeterBlockOffsets.EcdsaCurveNameLength),
            ecdsa_public_key=decode_binary_string(decoder, size=2 * SigningMeterBlockOffsets.EcdsaPublicKeyLength),
            )
    elif model_id == SigningMeterModels.SignedState and length == SigningMeterModelPayloadLengths.SignedState:
        result = SignedStateData(
            type=decoder.decode_16bit_uint(),
            status=decoder.decode_16bit_uint(),
            active_energy_exported_total=decoder.decode_32bit_uint(),
            active_energy_exported_total_scale_factor=decoder.decode_16bit_int(),
            active_power_total=decoder.decode_32bit_int(),
            active_power_total_scale_factor=decoder.decode_16bit_int(),
            server_id=decoder.decode_string(size=2 * SignedStateBlockOffsets.ServerIdLength),
            response_counter=decoder.decode_32bit_uint(),
            timestamp=decode_timestamp(decoder),
            di_state=decoder.decode_16bit_uint(),
            do_state=decoder.decode_16bit_uint(),
            last_di_modification=decode_timestamp(decoder),
            last_do_modification=decode_timestamp(decoder),
            metadata_1=decoder.decode_string(size=2 * SignedStateBlockOffsets.Metadata1Length),
            metadata_2=decoder.decode_string(size=2 * SignedStateBlockOffsets.Metadata2Length),
            metadata_3=decoder.decode_string(size=2 * SignedStateBlockOffsets.Metadata3Length),
            signature=decode_binary_string(decoder, size=2 * SignedStateBlockOffsets.SignatureLength),
            )
    else:
        result = decoder.decode_binary_string(size=2 * length)

    return result


def decode_timestamp(decoder):
    return SnapshotTimestamp(
        operating_seconds=decoder.decode_32bit_uint(),
        epoch_time_utc_seconds=decoder.decode_32bit_uint(),
        local_timezone_offset_minutes=decoder.decode_16bit_int())


def update_md_from_scaled_int32(md, value, scaler, unit):
    data = pack('>lbB', value, scaler, unit)
    # TODO: Clean up logging MD data.
    hexdump(data)
    md.update(data)


def update_md_from_scaled_uint32(md, value, scaler, unit):
    data = pack('>LbB', value, scaler, unit)
    # TODO: Clean up logging MD data.
    hexdump(data)
    md.update(data)


def update_md_from_string(md, string):
    length = pack('>L', len(string))
    # TODO: Clean up logging MD data.
    hexdump(length)
    hexdump(string)
    md.update(length)
    md.update(string)


def digest_for_snapshot_data(md, data):
    payload = data.payload
    digest = md()

    update_md_from_scaled_uint32(digest, payload.type, 0, DlmsUnits.UNITLESS)
    update_md_from_scaled_uint32(digest, payload.active_energy_exported_total,
        payload.active_energy_exported_total_scale_factor, DlmsUnits.WATT_HOURS)
    update_md_from_scaled_int32(digest, payload.active_power_total,
        payload.active_power_total_scale_factor, DlmsUnits.WATTS)
    update_md_from_string(digest, payload.server_id)
    update_md_from_scaled_uint32(digest, payload.response_counter, 0, DlmsUnits.UNITLESS)
    update_md_from_scaled_uint32(digest, payload.timestamp.operating_seconds, 0, DlmsUnits.SECONDS)
    update_md_from_scaled_uint32(digest, payload.timestamp.epoch_time_utc_seconds, 0, DlmsUnits.SECONDS)
    update_md_from_scaled_int32(digest, payload.timestamp.local_timezone_offset_minutes, 0, DlmsUnits.MINUTES)
    update_md_from_scaled_uint32(digest, payload.di_state, 0, DlmsUnits.UNITLESS)
    update_md_from_scaled_uint32(digest, payload.do_state, 0, DlmsUnits.UNITLESS)
    update_md_from_scaled_uint32(digest, payload.last_di_modification.operating_seconds, 0, DlmsUnits.SECONDS)
    update_md_from_scaled_uint32(digest, payload.last_di_modification.epoch_time_utc_seconds, 0, DlmsUnits.SECONDS)
    update_md_from_scaled_int32(digest, payload.last_di_modification.local_timezone_offset_minutes, 0, DlmsUnits.MINUTES)
    update_md_from_scaled_uint32(digest, payload.last_do_modification.operating_seconds, 0, DlmsUnits.SECONDS)
    update_md_from_scaled_uint32(digest, payload.last_do_modification.epoch_time_utc_seconds, 0, DlmsUnits.SECONDS)
    update_md_from_scaled_int32(digest, payload.last_do_modification.local_timezone_offset_minutes, 0, DlmsUnits.MINUTES)
    update_md_from_string(digest, payload.metadata_1)
    update_md_from_string(digest, payload.metadata_2)
    update_md_from_string(digest, payload.metadata_3)

    return digest.digest()


def get_block(client, offset):
    # Read and decode block header.
    decoder = client.get_device_block(offset, SunspecOffsets.HeaderLength)
    model_id = decoder.decode_16bit_uint()
    length = decoder.decode_16bit_uint()

    # Read and decode block payload.
    decoder = client.get_device_block(offset + SunspecOffsets.HeaderLength, length);
    payload = decode_block_payload(decoder, model_id, length);

    return SunspecModelData(model_id, length, payload)


def into_chunks(array, length):
    for i in range(0, len(array), length):
        yield array[i:i + length]


def is_namedtuple(value):
    # Quirks for identifying namedtuples.
    return isinstance(value, tuple) and type(value) != tuple


def is_snapshot_block_info(info):
    return info != None and info.is_snapshot


def parse_args():
    # Attempt to retrieve communication paramter defaults from environment
    # variables. This will allow short command lines for repeated invocations.
    device = os.getenv('MBTOOL_DEVICE')
    baud = auto_int(os.getenv('MBTOOL_BAUD', 19200))
    unit = auto_int(os.getenv('MBTOOL_UNIT', 42))
    timeout = auto_int(os.getenv('MBTOOL_TIMEOUT', 10))
    chunk = auto_int(os.getenv('MBTOOL_CHUNK', 125))

    parser = ArgumentParser(description='Signing Meter Modbus Tool',
        epilog='You may specify communication parameters also by environment variables. Use MBTOOL_DEVICE, MBTOOL_BAUD, MBTOOL_UNIT, MBTOOL_TIMEOUT, and MBTOOL_CHUNK.')
    # Default parser for communication parameters.
    parser.add_argument('--device', metavar='DEVICE', help='serial device', required=(device is None), default=device)
    parser.add_argument('--baud', metavar='BAUD', type=int, help='serial baud rate', default=baud)
    parser.add_argument('--timeout', metavar='SECONDS', type=float, help='request timeout', default=timeout)
    parser.add_argument('--unit', metavar='UNIT', type=int, help='Modbus RTU unit number', required=(unit is None), default=unit)
    parser.add_argument('--chunk-size', metavar='REGISTERS', type=int, help='Maximum amount of registers to read at once', default=chunk)

    subparsers = parser.add_subparsers(help='sub commands')

    # Read and interpret SunSpec block.
    get_block_parser = subparsers.add_parser('get-block', help='read and interpret SunSpec block')
    get_block_parser.set_defaults(func=get_block_command)
    get_block_parser.add_argument('offsets', metavar='OFFSET', type=auto_int, nargs='+',  help='Modbus block offset (words)')

    # Set meter time.
    set_parser = subparsers.add_parser('set', help='Set values')
    set_parser.set_defaults(func=set_values_command )
    set_parser.add_argument('--device-address', type=auto_int, help='Modbus device address')
    set_parser.add_argument('--baud-rate', type=auto_int, help='Modbus baud rate')
    set_parser.add_argument('--epoch-time', type=auto_int, help='Epoch time UTC [seconds]')
    set_parser.add_argument('--tz-offset', type=auto_int, help='Local timezone UTC offset [minutes]')
    set_parser.add_argument('--digital-output', type=auto_int, help='Digital output state')
    set_parser.add_argument('--meta1', help='Metadata string 1')
    set_parser.add_argument('--meta2', help='Metadata string 2')
    set_parser.add_argument('--meta3', help='Metadata string 3')

    # Request generating a snapshot (for a given snapshot name).
    create_snapshot_parser = subparsers.add_parser('create-snapshot', help='Create snapshot but don\'t fetch data')
    create_snapshot_parser.set_defaults(func=create_snapshot_command)
    create_snapshot_parser.add_argument('name', help='Snapshot name')

    # Request snapshot, wait for completion and get data.
    get_snapshot_parser = subparsers.add_parser('get-snapshot', help='Create snapshot and get data')
    get_snapshot_parser.set_defaults(func=get_snapshot_command)
    get_snapshot_parser.add_argument('name', help='Snapshot name')

    # Verify snapshot signature.
    verify_snapshot_parser = subparsers.add_parser('verify-snapshot', help='Verifies signature of snapshot (but does not create it)')
    verify_snapshot_parser.set_defaults(func=verify_snapshot_command)
    verify_snapshot_parser.add_argument('name', help='Snapshot name')

    # Hex-dump_command registers.
    dump_parser = subparsers.add_parser('dump', help='Dump registers')
    dump_parser.set_defaults(func=dump_command)
    dump_parser.add_argument('offset', metavar='OFFSET', type=auto_int, help='Modbus block offset (words)')
    dump_parser.add_argument('length', metavar='LENGTH', type=auto_int, help='Block length (words)')

    # The original main function from initial Modbus Tool.
    test_parser = subparsers.add_parser('main', help='run original test code from main')
    test_parser.set_defaults(func=test_main_command)
    test_parser.add_argument('--raw-data', action='store_true', help='Fetch raw data for unknown blocks')

    return parser.parse_args()


def print_model_data(data, indent=MODEL_DATA_INDENT):
    for name, value in data._asdict().items():
        if is_namedtuple(value):
            print('{}{}:'.format(indent, name))
            print_model_data(value, indent + MODEL_DATA_INDENT)
        else:
            print('{}{}: {}'.format(indent, name, value))


def register_hexdump(registers, offset=0):
    chunk_length = 8
    chunks = list(into_chunks(registers, chunk_length))

    start = offset

    for i in range(0, len(chunks)):
        chunk = chunks[i]

        # Hex data of registers.
        hex_chunk = ' '.join(map(lambda x: '{:04x}'.format(x), chunk))

        # Printable characters from big-endian register data.
        payload_chunk = b''.join(pack('>H', x) for x in chunk)
        printable = ''.join(map(lambda x: chr(x) if x >= 32 and x < 127 else '.', payload_chunk))

        print('{:8}: {:40} {}'.format(start, hex_chunk, printable))
        start += len(chunk)


#------------------------------------------------------------
# Program command implementations
#------------------------------------------------------------
def test_main_command(args):
    client = create_sunspec_sync_client(args)

    # print out all the device common block
    common = client.get_common_block()
    for key, value in iteritems(common):
        if key == "SunSpec_DID":
            value = SunspecModel.lookup(value)
        print("{:<20}: {}".format(key, value))

    # print out all the available device blocks
    blocks = client.get_all_device_blocks(args.raw_data)
    for block in blocks:
        print(block)

    client.client.close()


def get_block_command(args):
    client = create_sunspec_sync_client(args)

    for offset in args.offsets:
        data = get_block(client, offset)
        print_model_data(data)

    client.client.close()


def create_snapshot(client, block_info):
    result = False

    if block_info != None and block_info.is_snapshot and block_info.offset != None:
        result = client.write_registers(info.offset + SignedStateBlockOffsets.Status, SignedStateBlockStatus.UPDATING)

    return result


def dump_command(args):
    client = create_sunspec_sync_client(args)

    registers = client.read_holding_registers(args.offset, args.length)
    register_hexdump(registers, args.offset)

    client.client.close()


def set_values_command(args):
    client = create_sunspec_sync_client(args)

    # We are currently ignoring the device address from common block and the
    # snapshot status registers. Snapshots can be triggered by
    # 'create-snapshot' and 'get-snapshot'.

    # Quirks for setting device address AND baud rate in a single write
    # request.
    #
    # TODO: What about a more generic approach which works for other
    # consecutive values as well?
    if args.device_address != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.ModbusDeviceAddress
        builder = SunspecBuilder()
        builder.add_16bit_uint(args.device_address)
        if args.baud_rate != None:
            builder.add_32bit_uint(args.baud_rate)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    if args.device_address == None and args.baud_rate != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.ModbusBaudRate
        builder = SunspecBuilder()
        builder.add_32bit_uint(args.baud_rate)
        check_write_result(client.write_registers(offset, builder.to_registers()))


    if args.epoch_time != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.EpochTimeUtcSeconds
        builder = SunspecBuilder()
        builder.add_32bit_uint(args.epoch_time)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    if args.tz_offset != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.LocalTimezoneOffsetMinutes
        builder = SunspecBuilder()
        builder.add_16bit_int(args.tz_offset)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    if args.digital_output != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.DigitalOutputState
        builder = SunspecBuilder()
        builder.add_16bit_uint(args.digital_output)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    if args.meta1 != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.Metadata1
        builder = SunspecBuilder()
        builder.add_string(args.meta1, size=2 * SigningMeterBlockOffsets.Metadata1Length)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    if args.meta2 != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.Metadata2
        builder = SunspecBuilder()
        builder.add_string(args.meta2, size=2 * SigningMeterBlockOffsets.Metadata2Length)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    if args.meta3 != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.Metadata3
        builder = SunspecBuilder()
        builder.add_string(args.meta3, size=2 * SigningMeterBlockOffsets.Metadata3Length)
        check_write_result(client.write_registers(offset, builder.to_registers()))

    client.client.close()


def create_snapshot_command(args):
    client = create_sunspec_sync_client(args)
    info = block_info_for_short_name(args.name.lower())

    if not is_snapshot_block_info(info):
        print('\'{}\' is not a valid snapshot name.'.format(args.name))
        sys.exit(1)
    else:
        client.write_registers(info.offset + SignedStateBlockOffsets.Status, SignedStateBlockStatus.UPDATING)

    client.client.close()


def get_snapshot_command(args):
    client = create_sunspec_sync_client(args)
    info = block_info_for_short_name(args.name.lower())
    result = False

    if not is_snapshot_block_info(info):
        print('\'{}\' is not a valid snapshot name.'.format(args.name))
        sys.exit(1)
    else:
        status_offset = info.offset + SignedStateBlockOffsets.Status

        # Request snapshot update by writing to the snapshot's status register.
        client.write_registers(status_offset, SignedStateBlockStatus.UPDATING)

        # Pull snapshot status until it is no longer updating.
        status = SignedStateBlockStatus.UPDATING
        while status == SignedStateBlockStatus.UPDATING:
            status = client.read_holding_registers(status_offset, 1)[0]

        # Updating is done. Get and display snapshot data in case of success.
        if status == SignedStateBlockStatus.VALID:
            data = get_block(client, info.offset)
            print('Updating \'{}\' succeeded: {}'.format(info.short_name, status))
            print('Snapshot data:')
            print_model_data(data)
            result = True
        else:
            print('Updating \'{}\' failed: {}'.format(info.short_name, status))
            result = False

    client.client.close()
    if not result:
        sys.exit(1)


def verify_snapshot_command(args):
    client = create_sunspec_sync_client(args)
    info = block_info_for_short_name(args.name.lower())
    result = False

    signing_meter_data = get_block(client, SigningMeterOffsets.SigningMeterBlock)

    if not is_snapshot_block_info(info):
        print('\'{}\' is not a valid snapshot name.'.format(args.name))
        sys.exit(1)
    else:
        snapshot_data = get_block(client, info.offset)

        curve_name = signing_meter_data.payload.ecdsa_curve_name
        public_key = signing_meter_data.payload.ecdsa_public_key
        signature = snapshot_data.payload.signature

        print('Curve: {}'.format(signing_meter_data.payload.ecdsa_curve_name))
        print('Public key: {}'.format(binascii.hexlify(signing_meter_data.payload.ecdsa_public_key)))
        print('Snapshot data:')
        print_model_data(snapshot_data)
        print('Signature: {}'.format(binascii.hexlify(snapshot_data.payload.signature)))

        assert curve_name == b'secp256r1'
        curve = SECP256r1
        md = sha256

        print('Computing SHA-256 digest for snapshot data:')
        digest = digest_for_snapshot_data(md, snapshot_data)
        print('Snapshot data SHA-256 digest: {}'.format(binascii.hexlify(digest)))

        if len(public_key) == 0:
            print('Failed. Device has no public key.')
            result = False
        elif len(signature) == 0:
            print('Failed. Snapshot contains no signature.')
            result = False
        else:
            if verify_signed_digest(curve, md, public_key, signature, digest):
                print('Success.')
                result = True
            else:
                print('Failed.')
                result = False

    client.client.close()
    if not result:
        sys.exit(1)


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
