#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import namedtuple
from enum import IntEnum
from pprint import pprint
from pymodbus.constants import Endian
from pymodbus.client.sync import ModbusSerialClient
from pymodbus.payload import BinaryPayloadBuilder, BinaryPayloadDecoder
from six import iteritems
from struct import pack

import binascii
import os
import string


# --------------------------------------------------------------------------- #
# Logging
# --------------------------------------------------------------------------- #
import logging
_logger = logging.getLogger(__name__)
_logger.setLevel(logging.DEBUG)
logging.basicConfig()


Item = namedtuple('item', 'name, value')


# --------------------------------------------------------------------------- # 
# Sunspec Common Constants
# --------------------------------------------------------------------------- # 
class SunspecDefaultValue(object):
    """ A collection of constants to indicate if
    a value is not implemented.
    """
    Signed16        = 0x8000
    Unsigned16      = 0xffff
    Accumulator16   = 0x0000
    Scale           = 0x8000
    Signed32        = 0x80000000
    Float32         = 0x7fc00000
    Unsigned32      = 0xffffffff
    Accumulator32   = 0x00000000
    Signed64        = 0x8000000000000000
    Unsigned64      = 0xffffffffffffffff
    Accumulator64   = 0x0000000000000000
    String          = b'\x00'


class SunspecStatus(object):
    """ Indicators of the current status of a
    sunspec device
    """
    Normal  = 0x00000000
    Error   = 0xfffffffe
    Unknown = 0xffffffff


class SunspecIdentifier(object):
    """ Assigned identifiers that are pre-assigned
    by the sunspec protocol.
    """
    Sunspec = 0x53756e53


class SunspecModel(object):
    """ Assigned device indentifiers that are pre-assigned
    by the sunspec protocol.
    """
    #---------------------------------------------
    # 0xx Common Models
    #---------------------------------------------
    CommonBlock                              = 1
    AggregatorBlock                          = 2

    #---------------------------------------------
    # 1xx Inverter Models
    #---------------------------------------------
    SinglePhaseIntegerInverter               = 101
    SplitPhaseIntegerInverter                = 102
    ThreePhaseIntegerInverter                = 103
    SinglePhaseFloatsInverter                = 103
    SplitPhaseFloatsInverter                 = 102
    ThreePhaseFloatsInverter                 = 103

    #---------------------------------------------
    # 2xx Meter Models
    #---------------------------------------------
    SinglePhaseMeter                         = 201
    SplitPhaseMeter                          = 201
    WyeConnectMeter                          = 201
    DeltaConnectMeter                        = 201
    ThreePhaseMeter                          = 203

    #---------------------------------------------
    # 3xx Environmental Models
    #---------------------------------------------
    BaseMeteorological                       = 301
    Irradiance                               = 302
    BackOfModuleTemperature                  = 303
    Inclinometer                             = 304
    Location                                 = 305
    ReferencePoint                           = 306
    BaseMeteorological                       = 307
    MiniMeteorological                       = 308

    #---------------------------------------------
    # 4xx String Combiner Models             
    #---------------------------------------------
    BasicStringCombiner                      = 401
    AdvancedStringCombiner                   = 402

    #---------------------------------------------
    # 5xx Panel Models
    #---------------------------------------------
    PanelFloat                               = 501
    PanelInteger                             = 502

    #---------------------------------------------
    # 641xx Outback Blocks
    #---------------------------------------------
    OutbackDeviceIdentifier                  = 64110
    OutbackChargeController                  = 64111
    OutbackFMSeriesChargeController          = 64112
    OutbackFXInverterRealTime                = 64113
    OutbackFXInverterConfiguration           = 64114
    OutbackSplitPhaseRadianInverter          = 64115
    OutbackRadianInverterConfiguration       = 64116
    OutbackSinglePhaseRadianInverterRealTime = 64117
    OutbackFLEXNetDCRealTime                 = 64118
    OutbackFLEXNetDCConfiguration            = 64119
    OutbackSystemControl                     = 64120

    #---------------------------------------------
    # 64xxx Vender Extension Block
    #---------------------------------------------
    BsmSignedState                           = 64901

    EndOfSunSpecMap                          = 65535

    @classmethod
    def lookup(klass, code):
        """ Given a device identifier, return the
        device model name for that identifier

        :param code: The device code to lookup
        :returns: The device model name, or None if none available
        """
        values = dict((v, k) for k, v in iteritems(klass.__dict__)
            if not callable(v))
        return values.get(code, None)


class SunspecOffsets(object):
    """ Well known offsets that are used throughout
    the sunspec protocol
    """
    CommonBlock             = 40000
    CommonBlockLength       = 70
    AlternateCommonBlock    = 50000


class SigningMeterOffsets(object):
    SunSpecId                                = 40000
    CommonBlock                              = 40002
    MeterBlock                               = 40070
    BsmMeterBlock                            = 40177
    SignedCurrentStateBlock                  = 40471
    SignedTurnOnStateBlock                   = 40719
    SignedTurnOffStateBlock                  = 40967


class BsmMeterBlockOffsets(IntEnum):
    EPOCH_TIME_UTC_SECONDS                   = 63
    LOCAL_TIME_ZONE_OFFSET_MINUTES           = 65
    DIGITAL_OUTPUT_STATE                     = 67
    METADATA_1                               = 78
    METADATA_1_LENGTH                        = 70
    METADATA_2                               = 148
    METADATA_2_LENGTH                        = 50
    METADATA_3                               = 198
    METADATA_3_LENGTH                        = 50


class SignedStateBlockOffsets(object):
    Status                                   = 3


class SignedStateBlockStatus(IntEnum):
    VALID = 0
    INVALID = 1
    UPDATING = 2
    FAILED = 3


# --------------------------------------------------------------------------- # 
# Common Functions
# --------------------------------------------------------------------------- # 
def create_sunspec_sync_client(args):
    """ A quick helper method to create a sunspec
    client.

    :param args: command line arguments parsed by ArgumentParser
    :returns: an initialized SunspecClient
    """
    modbus = ModbusSerialClient(method='rtu', port=args.device, timeout=args.timeout, baudrate=args.baud, parity='E')
    modbus.connect()
    client = SunspecClient(modbus, unit=args.unit, chunk_size=args.chunk_size)
    client.initialize()
    return client


def auto_int(x):
    result = None

    if isinstance(x, int):
        # Pass-through integer values.
        result = x
    elif x != None:
        # Parse everything else but 'None' with auto base detection.
        result = int(x, 0)

    return result


def parse_args():
    # Attempt to retrieve communication paramter defaults from environment
    # variables. This will allow short command lines for repeated invocations.
    device = os.getenv('MBTOOL_DEVICE')
    baud = auto_int(os.getenv('MBTOOL_BAUD', 115200))
    unit = auto_int(os.getenv('MBTOOL_UNIT'))
    timeout = auto_int(os.getenv('MBTOOL_TIMEOUT', 10))
    chunk = auto_int(os.getenv('MBTOOL_CHUNK', 125))

    parser = ArgumentParser(description='Signing Meter Modbus Tool',
        epilog='You may specify communication parameters also by environment variables. Use MBTOOL_DEVICE, MBTOOL_BAUD, MBTOOL_UNIT, MBTOOL_TIMEOUT, and MBTOOL_CHUNK.')
    # Default parser for communication parameters.
    parser.add_argument('--device', metavar='DEVICE', help='serial device', required=(device is None), default=device)
    parser.add_argument('--baud', metavar='BAUD', type=int, help='serial baud rate', default=baud)
    parser.add_argument('--timeout', metavar='SECONDS', type=float, help='request timeout', default=timeout)
    parser.add_argument('--unit', metavar='UNIT', type=int, help='Modbus RTU unit number', required=(unit is None), default=unit)
    parser.add_argument('--chunk-size', metavar='REGISTERS', type=int, help='Maximum amount of registers to read at once', default=chunk)

    subparsers = parser.add_subparsers(help='sub commands')

    # The original main function from initial Modbus Tool.
    test_parser = subparsers.add_parser('main', help='run original test code from main')
    test_parser.set_defaults(func=test_main)
    test_parser.add_argument('--raw-data', action='store_true', help='Fetch raw data for unknown blocks')

    # Read and interpret SunSpec block.
    read_block_parser = subparsers.add_parser('read-block', help='read sunspec block')
    read_block_parser.set_defaults(func=read_block)
    read_block_parser.add_argument('--offset', type=auto_int, help='Modbus block offset (words)')
    read_block_parser.add_argument('--length', type=auto_int, help='Block length (words)')

    # Hex-dump registers.
    dump_parser = subparsers.add_parser('dump', help='Dump registers')
    dump_parser.set_defaults(func=dump)
    dump_parser.add_argument('--offset', type=auto_int, help='Modbus block offset (words)')
    dump_parser.add_argument('--length', type=auto_int, help='Block length (words)')

    # Set meter time.
    set_parser = subparsers.add_parser('set', help='Set values')
    set_parser.set_defaults(func=set_values )
    set_parser.add_argument('--epoch-time', type=auto_int, help='Epoch time UTC [seconds]')
    set_parser.add_argument('--tz-offset', type=auto_int, help='Local timezone UTC offset [minutes]')
    set_parser.add_argument('--meta1', help='Metadata string 1')
    set_parser.add_argument('--meta2', help='Metadata string 2')
    set_parser.add_argument('--meta3', help='Metadata string 3')

    # Request generating a snapshot (for a given snapshot name).
    snapshot_parser = subparsers.add_parser('snapshot', help='Create snapshot')
    snapshot_parser.set_defaults(func=snapshot)
    snapshot_parser.add_argument('name', help='Snapshot name')

    return parser.parse_args()


# --------------------------------------------------------------------------- # 
# Sunspec Client
# --------------------------------------------------------------------------- # 
class SunspecDecoder(BinaryPayloadDecoder):
    """ A decoder that deals correctly with the sunspec
    binary format.
    """

    def __init__(self, payload, byteorder, wordorder):
        """ Initialize a new instance of the SunspecDecoder

        .. note:: This is always set to big endian byte order
        as specified in the protocol.
        """
        byteorder = Endian.Big
        BinaryPayloadDecoder.__init__(self, payload, byteorder, wordorder)

    def decode_binary_string(self, size=1):
        return super().decode_string(size)

    def decode_string(self, size=1):
        """ Decodes a string from the buffer

        :param size: The size of the string to decode
        """
        string = super().decode_string(size)
        return string.split(SunspecDefaultValue.String)[0]

class SunspecBuilder(BinaryPayloadBuilder):
    def __init__(self, payload=None, byteorder=Endian.Big, wordorder=Endian.Big, repack=False):
        BinaryPayloadBuilder.__init__(self, payload, byteorder, wordorder, repack)

    def add_string(self, value, size=1):
        assert(size % 2 == 0)
        assert(len(value) <= size)

        # TODO: How to deal with non-ASCII characters? The PyModbus stack
        # operates on characters so we have to make assumptions about the
        # encoding.

        padding = '\x00' * (size - len(value))
        super().add_string(value + padding)

class SunspecClient(object):

    def __init__(self, client, unit=None, chunk_size=125):
        """ Initialize a new instance of the client

        :param client: The modbus client to use
        """
        self.client = client
        self.unit = unit
        self.chunk_size = chunk_size
        self.offset = SunspecOffsets.CommonBlock

    def initialize(self):
        """ Initialize the underlying client values

        :returns: True if successful, false otherwise
        """
        decoder  = self.get_device_block(self.offset, 2)
        if decoder.decode_32bit_uint() == SunspecIdentifier.Sunspec:
            return True
        self.offset = SunspecOffsets.AlternateCommonBlock
        decoder  = self.get_device_block(self.offset, 2)
        return decoder.decode_32bit_uint() == SunspecIdentifier.Sunspec

    def get_common_block(self):
        """ Read and return the sunspec common information
        block.

        :returns: A dictionary of the common block information
        """
        length  = SunspecOffsets.CommonBlockLength
        decoder = self.get_device_block(self.offset, length)
        return {
            'SunSpec_ID':       decoder.decode_32bit_uint(),
            'SunSpec_DID':      decoder.decode_16bit_uint(),
            'SunSpec_Length':   decoder.decode_16bit_uint(),
            'Manufacturer':     decoder.decode_string(size=32),
            'Model':            decoder.decode_string(size=32),
            'Options':          decoder.decode_string(size=16),
            'Version':          decoder.decode_string(size=16),
            'SerialNumber':     decoder.decode_string(size=32),
            'DeviceAddress':    decoder.decode_16bit_uint(),
            'Pad':              decoder.decode_16bit_uint(),
        }

    def get_device_block(self, offset, size):
        """ A helper method to retrieve the next device block

        .. note:: We will read 2 more registers so that we have
        the information for the next block.

        :param offset: The offset to start reading at
        :param size: The size of the offset to read
        :returns: An initialized decoder for that result
        """
        _logger.debug("reading device block[{}..{}]".format(offset, offset + size))

        registers = []
        remaining = size

        if size > 0:
            while remaining > 0:
                current_chunk = min(remaining, self.chunk_size)
                response = self.client.read_holding_registers(offset, current_chunk, unit=self.unit)

                registers += response.registers
                offset += current_chunk
                remaining -= current_chunk

        return SunspecDecoder.fromRegisters(registers)

    def get_all_device_blocks(self, raw_data=False):
        """ Retrieve all the available blocks in the supplied
        sunspec device.

        .. note:: Since we do not know how to decode the available
        blocks, this returns a list of dictionaries of the form:

            decoder: the-binary-decoder,
            model:   the-model-identifier (name)

        :returns: A list of the available blocks
        """
        blocks = []
        offset = self.offset + 2
        model  = SunspecModel.CommonBlock
        while model != SunspecModel.EndOfSunSpecMap:
            decoder = self.get_device_block(offset, 2)
            model   = decoder.decode_16bit_uint()
            start   = offset
            length  = decoder.decode_16bit_uint()

            offset += 2

            if raw_data:
                decoder = self.get_device_block(offset, length)

            offset += length

            blocks.append({
                'model' : model,
                'name'  : SunspecModel.lookup(model),
                'start' : start,
                'length': length,
            })
        return blocks

    def read_holding_registers(self, offset, length):
        _logger.debug('reading registers {}..{}'.format(offset, offset + length))

        registers = []
        remaining = length

        while remaining > 0:
            current_chunk = min(remaining, self.chunk_size)
            response = self.client.read_holding_registers(offset, current_chunk, unit=self.unit)

            registers += response.registers
            offset += current_chunk
            remaining -= current_chunk

        return registers

    def write_registers(self, offset, values):
        _logger.debug('write registers {} with {}'.format(offset, values))
        self.client.write_registers(offset, values, unit=self.unit)


#------------------------------------------------------------
# A quick test runner
#------------------------------------------------------------
def test_main(args):
    client = create_sunspec_sync_client(args)

    # print out all the device common block
    common = client.get_common_block()
    for key, value in iteritems(common):
        if key == "SunSpec_DID":
            value = SunspecModel.lookup(value)
        print("{:<20}: {}".format(key, value))

    # print out all the available device blocks
    blocks = client.get_all_device_blocks(args.raw_data)
    for block in blocks:
        print(block)

    client.client.close()


def read_block(args):
    client = create_sunspec_sync_client(args)
    decoder = client.get_device_block(args.offset, args.length)

    # FIXME: Complete and clean-up block decoding. Decode more than just signed
    # state blocks.
    entries = [
        Item('Model ID', decoder.decode_16bit_uint()),
        Item('Length', decoder.decode_16bit_uint()),
        Item('Type', decoder.decode_16bit_uint()),
        Item('Status', decoder.decode_16bit_uint()),
        Item('Active Energy Exported Total', (decoder.decode_32bit_uint(), decoder.decode_16bit_int(), decoder.decode_16bit_uint())),
        Item('Active Power Total', (decoder.decode_32bit_int(), decoder.decode_16bit_int(), decoder.decode_16bit_uint())),
        Item('Server ID', decoder.decode_string(size=16)),
        Item('Response Counter', decoder.decode_32bit_uint()),
        Item('Operating Seconds', decoder.decode_32bit_uint()),
        Item('Epoch Time UTC', decoder.decode_32bit_uint()),
        Item('Local Time Zone Offset', decoder.decode_16bit_int()),
        Item('Digital Input State', decoder.decode_16bit_uint()),
        Item('Digital Output State', decoder.decode_16bit_uint()),
        Item('Last Modification DI Operating Seconds', decoder.decode_32bit_uint()),
        Item('Last Modification DI Epoch Time UTC', decoder.decode_32bit_uint()),
        Item('Last Modification DI Local Time Zone Offset', decoder.decode_16bit_int()),
        Item('Last Modification DO Operating Seconds', decoder.decode_32bit_uint()),
        Item('Last Modification DO Epoch Time UTC', decoder.decode_32bit_uint()),
        Item('Last Modification DO Local Time Zone Offset', decoder.decode_16bit_int()),
        Item('Metadata 1', decoder.decode_string(size=140)),
        Item('Metadata 2', decoder.decode_string(size=100)),
        Item('Metadata 3', decoder.decode_string(size=100)),
    ]

    signature_length = decoder.decode_16bit_uint()
    raw = decoder.decode_binary_string(size=74)
    signature = binascii.hexlify(raw[:signature_length])

    entries.append(Item('Signature', signature))

    pprint(entries)

    client.client.close()


def into_chunks(array, length):
    for i in range(0, len(array), length):
        yield array[i:i + length]


def register_hexdump(registers, offset=0):
    chunk_length = 8
    chunks = list(into_chunks(registers, chunk_length))

    for i in range(0, len(chunks)):
        chunk = chunks[i]
        start = i * len(chunk) + offset

        # Hex data of registers.
        hex_chunk = ' '.join(map(lambda x: '{:04x}'.format(x), chunk))

        # Printable characters from big-endian register data.
        payload_chunk = b''.join(pack('>H', x) for x in chunk)
        printable = ''.join(map(lambda x: chr(x) if x >= 32 and x < 127 else '.', payload_chunk))

        print('{:8}: {:40} {}'.format(start, hex_chunk, printable))



def dump(args):
    client = create_sunspec_sync_client(args)

    registers = client.read_holding_registers(args.offset, args.length)
    register_hexdump(registers, args.offset)

    client.client.close()


def set_values(args):
    client = create_sunspec_sync_client(args)
    offset = None

    # TODO: Add support for setting the remaining values.

    if args.epoch_time != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.EPOCH_TIME_UTC_SECONDS
        builder = SunspecBuilder()
        builder.add_32bit_uint(args.epoch_time)
        client.write_registers(offset, builder.to_registers())

    if args.tz_offset != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.LOCAL_TIME_ZONE_OFFSET_MINUTES
        builder = SunspecBuilder()
        builder.add_16bit_int(args.tz_offset)
        client.write_registers(offset, builder.to_registers())

    if args.meta1 != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.METADATA_1
        builder = SunspecBuilder()
        builder.add_string(args.meta1, size=2 * BsmMeterBlockOffsets.METADATA_1_LENGTH)
        client.write_registers(offset, builder.to_registers())

    if args.meta2 != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.METADATA_2
        builder = SunspecBuilder()
        builder.add_string(args.meta2, size=2 * BsmMeterBlockOffsets.METADATA_2_LENGTH)
        client.write_registers(offset, builder.to_registers())

    if args.meta3 != None:
        offset = SigningMeterOffsets.BsmMeterBlock + BsmMeterBlockOffsets.METADATA_3
        builder = SunspecBuilder()
        builder.add_string(args.meta3, size=2 * BsmMeterBlockOffsets.METADATA_3_LENGTH)
        client.write_registers(offset, builder.to_registers())

    client.client.close()


def snapshot(args):
    client = create_sunspec_sync_client(args)

    trigger_offsets = \
        {
            'scs': SigningMeterOffsets.SignedCurrentStateBlock + SignedStateBlockOffsets.Status,
            'stons': SigningMeterOffsets.SignedTurnOnStateBlock + SignedStateBlockOffsets.Status,
            'stoffs': SigningMeterOffsets.SignedTurnOffStateBlock + SignedStateBlockOffsets.Status,
        }

    offset = trigger_offsets[args.name.lower()]

    if offset != None:
        client.write_registers(offset, SignedStateBlockStatus.UPDATING)

    client.client.close()


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
