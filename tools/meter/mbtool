#!/usr/bin/env python3

from argparse import ArgumentParser
from collections import namedtuple
from enum import IntEnum
from pprint import pprint
from pymodbus.client.sync import ModbusSerialClient
from six import iteritems
from struct import pack
from sunspec.client import SunspecClient, SunspecBuilder
from sunspec.constants import SunspecModel, SunspecOffsets, SunspecIdentifier, SunspecDefaultValue

import binascii
import os
import string


SunspecModelData = namedtuple('SunspecModelData',
    [
        'model_id',
        'length',
        'payload',
    ])
ScaledValue = namedtuple('ScaledValue', 'value, scaler, unit')
SnapshotTimestamp = namedtuple('SnapshotTimestamp', 'operating_seconds, epoch_time_utc_seconds, local_timezone_offset_minutes')
SigningMeterData = namedtuple('SigningMeterData',
    [
        'modbus_address',
        'modbus_baud_rate',
        'error_code',
        'serial_number_meter',
        'serial_number_communication_module',
        'software_version_meter',
        'software_version_communication_module',
        'meter_address_1',
        'meter_address_2',
        'power_down_counter',
        'response_counter',
        'current_time',
        'di_state',
        'do_state',
        'last_di_modification',
        'last_do_modification',
        'metadata_1',
        'metadata_2',
        'metadata_3',
        'ecdsa_curve_name',
        'ecdsa_public_key',
    ])
SignedStateData = namedtuple('SignedStateData',
    [
        'type',
        'status',
        'active_energy_exported_total',
        'active_power_total',
        'server_id',
        'response_counter',
        'timestamp',
        'di_state',
        'do_state',
        'last_di_modification',
        'last_do_modification',
        'metadata_1',
        'metadata_2',
        'metadata_3',
        'signature',
    ])



# --------------------------------------------------------------------------- # 
# Signing Meter Common Constants
# --------------------------------------------------------------------------- # 
class SigningMeterOffsets(IntEnum):
    SunSpecId                                = 40000
    CommonBlock                              = 40002
    ThreePhaseMeterBlock                     = 40070
    SigningMeterBlock                        = 40177
    SignedCurrentStateBlock                  = 40471
    SignedTurnOnStateBlock                   = 40719
    SignedTurnOffStateBlock                  = 40967
    EndOfSunSpecMapBlock                     = 41215


class SigningMeterModels(IntEnum):
    SigningMeter                             = SunspecModel.VendorPrivateStart + 0
    SignedState                              = SunspecModel.VendorPrivateStart + 1


class SigningMeterModelPayloadLengths(IntEnum):
    SigningMeter                             = 294 - 2
    SignedState                              = 248 - 2


class SigningMeterBlockOffsets(IntEnum):
    ErrorCodeLength                          = 4
    SerialNumberMeterLength                  = 8
    SerialNumberCommunicationModuleLength    = 8
    SoftwareVersionMeterLength               = 8
    SoftwareVersionCommunicationModuleLength = 8
    MeterAddress1Length                      = 8
    MeterAddress2Length                      = 8
    EpochTimeUtcSeconds                      = 63
    LocalTimezoneOffsetMinutes               = 65
    DigitalOutputState                       = 67
    Metadata1                                = 78
    Metadata1Length                          = 70
    Metadata2                                = 148
    Metadata2Length                          = 50
    Metadata3                                = 198
    Metadata3Length                          = 50
    EcdsaCurveNameLength                     = 8
    EcdsaPublicKeyLength                     = 37


class SignedStateBlockOffsets(object):
    Status                                   = 3
    ServerId                                 = 12
    ServerIdLength                           = 8
    Metadata1Length                          = SigningMeterBlockOffsets.Metadata1Length
    Metadata2Length                          = SigningMeterBlockOffsets.Metadata2Length
    Metadata3Length                          = SigningMeterBlockOffsets.Metadata3Length
    SignatureLength                          = 37


class SignedStateBlockStatus(IntEnum):
    VALID = 0
    INVALID = 1
    UPDATING = 2
    FAILED = 3


# --------------------------------------------------------------------------- # 
# Common Functions
# --------------------------------------------------------------------------- # 
def create_sunspec_sync_client(args):
    """ A quick helper method to create a sunspec
    client.

    :param args: command line arguments parsed by ArgumentParser
    :returns: an initialized SunspecClient
    """
    modbus = ModbusSerialClient(method='rtu', port=args.device, timeout=args.timeout, baudrate=args.baud, parity='E')
    modbus.connect()
    client = SunspecClient(modbus, unit=args.unit, chunk_size=args.chunk_size)
    client.initialize()
    return client


def auto_int(x):
    result = None

    if isinstance(x, int):
        # Pass-through integer values.
        result = x
    elif x != None:
        # Parse everything else but 'None' with auto base detection.
        result = int(x, 0)

    return result


def decode_binary_string(decoder, size):
    length = decoder.decode_16bit_uint()
    string = decoder.decode_binary_string(size=size)

    assert length <= size
    return string[:length]


def decode_block_payload(decoder, model_id, length):
    result = None

    # FIXME: Add support for remaining blocks of signing meter.

    if model_id == SigningMeterModels.SigningMeter and length == SigningMeterModelPayloadLengths.SigningMeter:
        result = SigningMeterData(
            modbus_address=decoder.decode_16bit_uint(),
            modbus_baud_rate=decoder.decode_32bit_uint(),
            error_code=decoder.decode_string(size=2 * SigningMeterBlockOffsets.ErrorCodeLength),
            serial_number_meter=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SerialNumberMeterLength),
            serial_number_communication_module=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SerialNumberCommunicationModuleLength),
            software_version_meter=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SoftwareVersionMeterLength),
            software_version_communication_module=decoder.decode_string(size=2 * SigningMeterBlockOffsets.SoftwareVersionCommunicationModuleLength),
            meter_address_1=decoder.decode_string(size=2 * SigningMeterBlockOffsets.MeterAddress1Length),
            meter_address_2=decoder.decode_string(size=2 * SigningMeterBlockOffsets.MeterAddress2Length),
            power_down_counter=decoder.decode_32bit_uint(),
            response_counter=decoder.decode_32bit_uint(),
            current_time=decode_timestamp(decoder),
            di_state=decoder.decode_16bit_uint(),
            do_state=decoder.decode_16bit_uint(),
            last_di_modification=decode_timestamp(decoder),
            last_do_modification=decode_timestamp(decoder),
            metadata_1=decoder.decode_string(size=2 * SigningMeterBlockOffsets.Metadata1Length),
            metadata_2=decoder.decode_string(size=2 * SigningMeterBlockOffsets.Metadata2Length),
            metadata_3=decoder.decode_string(size=2 * SigningMeterBlockOffsets.Metadata3Length),
            ecdsa_curve_name=decoder.decode_string(size=2 * SigningMeterBlockOffsets.EcdsaCurveNameLength),
            ecdsa_public_key=decode_binary_string(decoder, size=2 * SigningMeterBlockOffsets.EcdsaPublicKeyLength),
            )
    elif model_id == SigningMeterModels.SignedState and length == SigningMeterModelPayloadLengths.SignedState:
        result = SignedStateData(
            type=decoder.decode_16bit_uint(),
            status=decoder.decode_16bit_uint(),
            active_energy_exported_total=decode_scaled_uint32(decoder),
            active_power_total=decode_scaled_int32(decoder),
            server_id=decoder.decode_string(size=2 * SignedStateBlockOffsets.ServerIdLength),
            response_counter=decoder.decode_32bit_uint(),
            timestamp=decode_timestamp(decoder),
            di_state=decoder.decode_16bit_uint(),
            do_state=decoder.decode_16bit_uint(),
            last_di_modification=decode_timestamp(decoder),
            last_do_modification=decode_timestamp(decoder),
            metadata_1=decoder.decode_string(size=2 * SignedStateBlockOffsets.Metadata1Length),
            metadata_2=decoder.decode_string(size=2 * SignedStateBlockOffsets.Metadata2Length),
            metadata_3=decoder.decode_string(size=2 * SignedStateBlockOffsets.Metadata3Length),
            signature=decode_binary_string(decoder, size=2 * SignedStateBlockOffsets.SignatureLength),
            )
    else:
        result = decoder.decode_binary_string(size=2 * length)

    return result


def decode_scaled_int32(decoder):
    return ScaledValue(
        value=decoder.decode_32bit_int(),
        scaler=decoder.decode_16bit_int(),
        unit=decoder.decode_16bit_uint())


def decode_scaled_uint32(decoder):
    return ScaledValue(
        value=decoder.decode_32bit_uint(),
        scaler=decoder.decode_16bit_int(),
        unit=decoder.decode_16bit_uint())


def decode_timestamp(decoder):
    return SnapshotTimestamp(
        operating_seconds=decoder.decode_32bit_uint(),
        epoch_time_utc_seconds=decoder.decode_32bit_uint(),
        local_timezone_offset_minutes=decoder.decode_16bit_int())


def into_chunks(array, length):
    for i in range(0, len(array), length):
        yield array[i:i + length]


def parse_args():
    # Attempt to retrieve communication paramter defaults from environment
    # variables. This will allow short command lines for repeated invocations.
    device = os.getenv('MBTOOL_DEVICE')
    baud = auto_int(os.getenv('MBTOOL_BAUD', 115200))
    unit = auto_int(os.getenv('MBTOOL_UNIT'))
    timeout = auto_int(os.getenv('MBTOOL_TIMEOUT', 10))
    chunk = auto_int(os.getenv('MBTOOL_CHUNK', 125))

    parser = ArgumentParser(description='Signing Meter Modbus Tool',
        epilog='You may specify communication parameters also by environment variables. Use MBTOOL_DEVICE, MBTOOL_BAUD, MBTOOL_UNIT, MBTOOL_TIMEOUT, and MBTOOL_CHUNK.')
    # Default parser for communication parameters.
    parser.add_argument('--device', metavar='DEVICE', help='serial device', required=(device is None), default=device)
    parser.add_argument('--baud', metavar='BAUD', type=int, help='serial baud rate', default=baud)
    parser.add_argument('--timeout', metavar='SECONDS', type=float, help='request timeout', default=timeout)
    parser.add_argument('--unit', metavar='UNIT', type=int, help='Modbus RTU unit number', required=(unit is None), default=unit)
    parser.add_argument('--chunk-size', metavar='REGISTERS', type=int, help='Maximum amount of registers to read at once', default=chunk)

    subparsers = parser.add_subparsers(help='sub commands')

    # The original main function from initial Modbus Tool.
    test_parser = subparsers.add_parser('main', help='run original test code from main')
    test_parser.set_defaults(func=test_main_command)
    test_parser.add_argument('--raw-data', action='store_true', help='Fetch raw data for unknown blocks')

    # Read and interpret SunSpec block.
    read_block_command_parser = subparsers.add_parser('read-block', help='read sunspec block')
    read_block_command_parser.set_defaults(func=read_block_command)
    read_block_command_parser.add_argument('--offset', type=auto_int, help='Modbus block offset (words)')

    # Hex-dump_command registers.
    dump_parser = subparsers.add_parser('dump', help='Dump registers')
    dump_parser.set_defaults(func=dump_command)
    dump_parser.add_argument('--offset', type=auto_int, help='Modbus block offset (words)')
    dump_parser.add_argument('--length', type=auto_int, help='Block length (words)')

    # Set meter time.
    set_parser = subparsers.add_parser('set', help='Set values')
    set_parser.set_defaults(func=set_values_command )
    set_parser.add_argument('--epoch-time', type=auto_int, help='Epoch time UTC [seconds]')
    set_parser.add_argument('--tz-offset', type=auto_int, help='Local timezone UTC offset [minutes]')
    set_parser.add_argument('--meta1', help='Metadata string 1')
    set_parser.add_argument('--meta2', help='Metadata string 2')
    set_parser.add_argument('--meta3', help='Metadata string 3')

    # Request generating a snapshot_command (for a given snapshot_command name).
    snapshot_parser = subparsers.add_parser('snapshot', help='Create snapshot_command')
    snapshot_parser.set_defaults(func=snapshot_command)
    snapshot_parser.add_argument('name', help='Snapshot name')

    return parser.parse_args()


def register_hexdump(registers, offset=0):
    chunk_length = 8
    chunks = list(into_chunks(registers, chunk_length))

    start = offset

    for i in range(0, len(chunks)):
        chunk = chunks[i]

        # Hex data of registers.
        hex_chunk = ' '.join(map(lambda x: '{:04x}'.format(x), chunk))

        # Printable characters from big-endian register data.
        payload_chunk = b''.join(pack('>H', x) for x in chunk)
        printable = ''.join(map(lambda x: chr(x) if x >= 32 and x < 127 else '.', payload_chunk))

        print('{:8}: {:40} {}'.format(start, hex_chunk, printable))
        start += len(chunk)


#------------------------------------------------------------
# Program command implementations
#------------------------------------------------------------
def test_main_command(args):
    client = create_sunspec_sync_client(args)

    # print out all the device common block
    common = client.get_common_block()
    for key, value in iteritems(common):
        if key == "SunSpec_DID":
            value = SunspecModel.lookup(value)
        print("{:<20}: {}".format(key, value))

    # print out all the available device blocks
    blocks = client.get_all_device_blocks(args.raw_data)
    for block in blocks:
        print(block)

    client.client.close()


def read_block_command(args):
    client = create_sunspec_sync_client(args)

    # Read and decode block header.
    decoder = client.get_device_block(args.offset, SunspecOffsets.HeaderLength)
    model_id = decoder.decode_16bit_uint()
    length = decoder.decode_16bit_uint()

    # Read and decode block payload.
    decoder = client.get_device_block(args.offset + SunspecOffsets.HeaderLength, length);
    payload = decode_block_payload(decoder, model_id, length);

    data = SunspecModelData(model_id, length, payload)
    # TODO: Provide a better readable output.
    pprint(data)

    client.client.close()


def dump_command(args):
    client = create_sunspec_sync_client(args)

    registers = client.read_holding_registers(args.offset, args.length)
    register_hexdump(registers, args.offset)

    client.client.close()


def set_values_command(args):
    client = create_sunspec_sync_client(args)
    offset = None

    # TODO: Add support for setting the remaining values.

    if args.epoch_time != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.EpochTimeUtcSeconds
        builder = SunspecBuilder()
        builder.add_32bit_uint(args.epoch_time)
        client.write_registers(offset, builder.to_registers())

    if args.tz_offset != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.LocalTimezoneOffsetMinutes
        builder = SunspecBuilder()
        builder.add_16bit_int(args.tz_offset)
        client.write_registers(offset, builder.to_registers())

    if args.meta1 != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.Metadata1
        builder = SunspecBuilder()
        builder.add_string(args.meta1, size=2 * SigningMeterBlockOffsets.Metadata1Length)
        client.write_registers(offset, builder.to_registers())

    if args.meta2 != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.Metadata2
        builder = SunspecBuilder()
        builder.add_string(args.meta2, size=2 * SigningMeterBlockOffsets.Metadata2Length)
        client.write_registers(offset, builder.to_registers())

    if args.meta3 != None:
        offset = SigningMeterOffsets.SigningMeterBlock + SigningMeterBlockOffsets.Metadata3
        builder = SunspecBuilder()
        builder.add_string(args.meta3, size=2 * SigningMeterBlockOffsets.Metadata3Length)
        client.write_registers(offset, builder.to_registers())

    client.client.close()


def snapshot_command(args):
    client = create_sunspec_sync_client(args)

    trigger_offsets = \
        {
            'scs': SigningMeterOffsets.SignedCurrentStateBlock + SignedStateBlockOffsets.Status,
            'stons': SigningMeterOffsets.SignedTurnOnStateBlock + SignedStateBlockOffsets.Status,
            'stoffs': SigningMeterOffsets.SignedTurnOffStateBlock + SignedStateBlockOffsets.Status,
        }

    offset = trigger_offsets[args.name.lower()]

    if offset != None:
        client.write_registers(offset, SignedStateBlockStatus.UPDATING)

    client.client.close()


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
